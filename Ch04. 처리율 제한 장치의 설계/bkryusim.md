# Ch04. 처리율 제한 장치의 설계

### 질문

> 처리율 제한 장치는 꼭 필요할까요? 항상 좋은 효과를 보여줄까요?
* 처리율 제한 장치를 설계하고자 합니다. 어떻게 적절한 분당 처리량을 결정할 수 있을까요?
* 단일 처리율 제한 장치를 미들웨어로 사용하는 경우 트래픽이 많아지면 어떤 문제가 발생할 수 있을까요? 어떻게 해결할 수 있을까요?

<details>
<summary><h4>해설</h4></summary>

> 처리율 제한 장치는 꼭 필요할까요? 항상 좋은 효과를 보여줄까요?
* 충분히 많은 트래픽이 발생하지 않는 상황에서 처리율 제한 장치를 설계하는 것은, 오히려 거대한 시스템의 복잡도 때문에 더 큰 비용을 지불해야할 수도 있습니다. 

> 처리율 제한 장치를 설계하고자 합니다. 어떻게 적절한 분당 처리량을 결정할 수 있을까요?
* 처리율 제한의 목적은 서버의 과부하를 방지하기 위해 진행합니다. 먼저 부하 테스트를 통해 하나의 서버 인스턴스가 어느정도 부하를 견딜 수 있는지 측정한 후, TPS를 바탕으로 적절한 수준의 처리율 제한장치를 설계해 적용하고, 다시 처리율 제한 장치를 포함하여 부하 테스트를 진행해 전체 시스템 안정성을 검증하고 결과값을 피드백하여 값을 수정할 수 있습니다.

> 단일 처리율 제한 장치를 미들웨어로 사용하는 경우 트래픽이 많아지면 어떤 문제가 발생할 수 있을까요? 어떻게 해결할 수 있을까요?
* 단일 처리율 제한 장치를 미들웨어로 사용하면 처리율 제한 장치에 장애가 발생하면 전체 시스템에 장애가 발생하는 SPOF가 될 수 있습니다. 따라서 처리율 제한 장치 앞에 로드밸런서를 두고, 처리율 제한 장치를 거친 트래픽이 다시 애플리케이션 서비스들의 로드밸런서로 향하게 할 수 있습니다. 처리율 제한 장치들끼리는 Redis 등의 글로벌 캐시를 사용해 데이터를 공유하여 동기화 문제를 해결합니다.
</details>


<br>

### 질문

> S&P 500에 속한 200개 종목의 주식 데이터를 API를 통해 수집하려고 합니다. API는 유료 서비스로 결제 사용자에 한해 제공되며, 1분에 50개의 토큰을 추가하는 토큰 버킷 정책을 갖고 있습니다. 처리율이 제한되는 상황에서 안전하게 500개 종목을 모두 수집할 방법을 생각해 주세요. 
* 서버 입장에서는 1분에 한 번씩 스파이크가 발생하는 요청 그래프가 그려질 것 같습니다. 서버측에서 요청이 고르게 발생하도록 하려면 어떻게 수집하면 좋을까요?
* 같은 서버를 운영하는 운영자의 입장이 되었습니다. 결제 금액에 따라 토큰 제공량의 개수를 다르게 설정하고자 할 때, 적절한 시스템 설계를 제시해 주세요.

<details>
<summary><h4>해설</h4></summary>

> S&P 500에 속한 200개 종목의 주식 데이터를 API를 통해 수집하려고 합니다. API는 1분에 50개의 토큰을 추가하는 토큰 버킷 정책을 갖고 있습니다. 처리율이 제한되는 상황에서 안전하게 500개 종목을 모두 수집할 방법을 생각해 주세요.
* 10개씩 비동기적으로 GET 요청을 보낸 뒤, 1분간 Sleep합니다. 돌아오는 요청은 백그라운드 스레드에서 DB에 저장하면 거의 일정하게 1분에 10개 종목씩 측정할 수 있습니다.

> 서버 입장에서는 1분에 한 번씩 스파이크가 발생하는 요청 그래프가 그려질 것 같습니다. 서버측에서 요청이 고르게 발생하도록 하려면 클라이언트가 어떻게 수집하면 좋을까요?
* 단일 스레드로는 힘들 것 같습니다. 예를 들어 1분에 200개의 요청이 필요하다고 하면, 60초/200 = 0.3초에 한번씩, 비동기적으로 서버에 값을 요청하고 콜백 함수를 통해 DB에 저장합니다. WebClient등 event loop기반으로 리액티브하게 동작하는 클라이언트를 사용하면 더 효율적입니다.

> 같은 서버를 운영하는 운영자의 입장이 되었습니다. 사용자의 결제 금액에 따라 토큰 제공량의 개수를 다르게 설정하고자 할 때, 적절한 시스템 설계를 제시해 주세요.
* 사용자의 결제 정보 및 토큰 수를 파악하기 위해 인증을 먼저 진행합니다. 이후 사용자 ID를 key값으로 하고, 현재 버킷 토큰 개수와 최대 버킷 토큰 개수를 함께 저장합니다. 이후 버킷에 토큰을 초기화할 때는 함께 저장되어 있는 토큰의 개수를 바탕으로 초기화합니다.
</details>
