# Ch07. 분산 시스템을 위한 유일 ID 생성기 설계

### snowflake에 대해 설명해 주세요.

* snowflake는 단점이 없을까요? 어떤 단점이 있을까요?

<details>
<summary><h4>해설</h4></summary>

> snowflake에 대해 설명해 주세요.
* snowflake는 분산 환경에서 시간 순으로 정렬이 되면서, 유일한 ID를 얻을 수 있는 키를 생성하는 방법입니다.
* 64비트의 키를 타임스탬프, 데이터센터 ID, 서버 ID, 일련번호로 나누어 각각의 서버에서 ID를 생성합니다.

> snowflake는 단점이 없을까요? 어떤 단점이 있을까요?
* 비트 설계를 변경할 때, 기존의 모든 ID들을 변경해야 하기 때문에 migration 시 큰 문제를 겪게 될 것 같습니다.

</details>


<br>

### UUID v4를 키로 설정하면 AUTO_INCREMENT BIGINT 값을 키로 설정하는 것에 비해 어떤 단점이 있을까요? 근거와 함께 설명해 주세요.

* UUID를 pk로 사용할 때 string으로 저장하면 몇 바이트를 차지할까요?
* UUID v1을 사용하면 UUID v4를 사용할 때에 비해 삽입 쿼리 수행 시 성능 이점을 얻을 수 있습니다. 왜, 그리고 어떻게 가능한걸까요? 

<details>
<summary><h4>해설</h4></summary>

> UUID v4를 키로 설정하면 AUTO_INCREMENT BIGINT 값을 키로 설정하는 것에 비해 성능상 어떤 단점이 있을까요? 근거와 함께 설명해 주세요.
* UUID v4의 크기는 16바이트입니다. 평범하게 BIGINT로 지정하는 것에 비해 ID를 위해 2배 크기를 차지합니다. 때문에 디스크 용량을 많이 차지하게 되어 버퍼캐시 효율이 떨어질 수 있습니다.
* Clustered Index의 크기가 2배이기 때문에, Secondary Index를 추가할 때 마다 인덱스 파일의 크기도 덩달아 커지게 됩니다. 인덱스를 많이 설정할수록 인덱스 파일의 크기가 커지고, 메모리에 로드해야하는 인덱스 트리의 크기가 커져 성능 저하가 발생할 수 있습니다.
* UUID v4는 정렬되지 않은 값이기 때문에, 새로운 데이터를 삽입할 때 인덱스 재정렬이 많이 이루어지기 떄문에 삽입 성능 저하가 발생합니다.

> UUID를 pk로 사용할 때 string으로 저장하면 몇 바이트를 차지할까요? 개선할 수 있을까요? 
* UUID는 128비트 정보를 이용해 생성하지만, 문자열로 나타내는 경우 4개의 하이픈 문자를 포함해 36자의 문자열을 갖게 됩니다. 이 36자리 문자열을 그대로 DB에 저장하게 되면 DB charset 설정에 따라 utf8인 경우 약 108바이트, utf8mb4인 경우 144바이트까지 차지하게 됩니다.
* 따라서 하이픈을 제거하고 hex값을 binary로 변환해 저장하면 pk 크기를 16바이트로 줄일 수 있습니다. MySQL의 경우 UUID_TO_BIN() 내장함수를 사용할 수 있습니다.

> UUID v1을 사용하면 UUID v4를 사용할 때에 비해 삽입 쿼리 수행 시 성능 이점을 얻을 수 있습니다. 왜, 그리고 어떻게 가능한걸까요?
* UUID v4는 완전 랜덤값인 반면, UUID v1은 timestamp, MAC address, 랜덤 노드 값을 통해 생성됩니다. 이 때 하이픈으로 구분된 그룹 중 1, 2, 3번 그룹은 각각 타임스탬프의 low, mid, high(+버전) 비트들을 표현합니다. 
* 때문에 1번 그룹과 3번 그룹의 위치를 스왑한 뒤 저장하면, UUID PK가 시간순으로 정렬되는 효과를 얻을 수 있습니다. 그래서 삽입 시 leaf에 삽입해도 트리 재정렬이 크게 일어나지 않고, AUTO_INCREMENT와 유사한 삽입 성능을 얻을 수 있습니다.
</details>
