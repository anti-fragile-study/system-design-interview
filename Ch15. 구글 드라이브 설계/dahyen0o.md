# Ch15. 구글 드라이브 설계

### 구글 드라이브를 설계하려고 한다. 파일 업로드, 파일 다운로드 기능만 존재할 때 대략적으로 설계해보시오.
* 큰 파일을 업로드하는 경우 많은 네트워크 대역폭을 사용한다. 이를 최적화하는 방법은?

<details>
<summary><h4>해설</h4></summary>

> 구글 드라이브를 설계하려고 한다. 파일 업로드, 파일 다운로드 기능만 존재할 때 대략적으로 설계해보시오. 
<img src="https://github.com/anti-fragile-study/system-design-interview/assets/64001680/861c433e-29fa-4773-bc4f-7552bf1a7d14" width="40%">

> 큰 파일을 업로드하는 경우 많은 네트워크 대역폭을 사용한다. 이를 최적화하는 방법은?
* 델타 동기화: 파일이 수정될 경우, 전체 파일이 아닌 수정된 파일 데이터만 네트워크로 전송한다. 이를 위해선 파일을 일정 크기의 블록 단위로 관리해야 한다.
* 압축: 블록 단위로 나뉘어진 파일을 각각 압축해 전송되는 데이터의 양을 줄일 수 있다.
</details>


<br>

### 여러 사용자가 하나의 파일을 동시에 수정해 동시성 문제가 발생할 수 있다. 이를 해결하는 방법은?

* 한 클라이언트가 파일을 편집하거나 추가했다는 사실을 다른 클라이언트가 감지하는 방법은?
* 알림 서비스를 어떤 방식을 이용해서 구현하고 싶은가? 이유는?

<details>
<summary><h4>해설</h4></summary>

> 여러 사용자가 하나의 파일을 동시에 수정해 동시성 문제가 발생할 수 있다. 이를 해결하는 방법은?
* 먼저 처리된 사용자 요청을 승낙하고, 나중에 처리된 변경은 충돌이 발생한 것으로 처리하는 방식을 도입할 수 있다.
* 충돌이 발생하면 서버에 저장된 최신 버전과 사용자의 로컬 버전의 데이터가 상이할 것이다. 이때 사용자에게 두 파일을 합치거나 새로운 사본을 생성하는 선택지를 제공할 수 있다.

> 한 클라이언트가 파일을 편집하거나 추가했다는 사실을 다른 클라이언트가 감지하는 방법은?
* 1-a. 클라이언트 A가 접속 중이고 다른 클라이언트가 파일을 변경하면 알림 서비스가 클라이언트 A에게 알린다.
* 1-b. 클라이언트 A가 접속 중이 아니라면 데이터는 캐시에 보관되고, 접속할 때 새 버전을 가져간다.
* 2. 파일 변경을 감지한 클라이언트는 API 서버를 통해 메타데이터를 새로 가져가고, 그 다음 블록들을 다운받아 파일을 재구성한다.

> 알림 서비스를 어떤 방식을 이용해서 구현하고 싶은가? 이유는?
* 롱 폴링과 웹소켓 중 롱폴링을 사용하고 싶다.
* 채팅 서비스와 달리 양방향 통신이 필요하지 않고 웹소켓은 실시간 양방향 통신이 요구될 때 더 적합하다.
* 또한 이 경우 단시간에 많은 양의 데이터를 보낼 일이 없기 때문이다.
</details>
