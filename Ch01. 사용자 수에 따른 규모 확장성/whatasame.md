

# Ch01. 사용자 수에 따른 규모 확장성

### 캐시를 사용하면 어떤 점을 고려해야하나?

* 캐시 사용 시 트랜잭션 측면에서 데이터의 일관성이 깨질 수 있다. 어떤 경우에 발생하고 어떻게 해결할 수 있는가?
* 캐시에서 잦은 eviction이 발생할 때 overprovision로 해결할 수 있다. 그런데 물리적인 메모리보다 더 많은 용량을 할당했는데 어떻게 동작하는 걸까?

<details>
<summary><h4>해설</h4></summary>


> 캐시를 사용하면 어떤 점을 고려해야하나?
- **데이터 갱신은 자주 일어나지 않지만 참조는 빈번하게 일어날 때 고려**한다.
- **중요한 데이터는 영속화**해야한다. 캐시는 응답 속도를 위해 휘발성 메모리에 두기 때문이다.
- **적절한 만료 정책을 사용**해야한다. 만료되지 않을 경우 캐시 서버가 동작하지 않을 수 있다. 만료 시간이 너무 짧은 경우 데이터베이스를 자주 읽게 되어 캐시 구조의 의미가 약해진다. 반대로 만료 시간이 너무 긴 경우 원본과 차이가 날 가능성이 높아진다.
- **일관성을 유지**한다. 저장소의 원본을 갱신하는 연산과 캐시를 갱신하는 연산이 단일 트랜잭션으로 처리되지 않는 경우 일관성이 깨질 수 있다.
- **단일 장애 지점이 되면 안된다.** 캐시 서버를 한 대만 두지 않고 여러 지역에 분산시킨다.
- **캐시 메모리를 충분히 설정**한다. 캐시 메모리가 작으면 eviction이 자주 발생해 성능이 나빠진다. 캐시 메모리를 overprovision하여 해결할 수 있다.
- **적절한 eviction 정책을 사용**한다. LRU, LFU, FIFO 등이 있다.

> 캐시 사용 시 트랜잭션 측면에서 데이터의 일관성이 깨질 수 있다. 어떤 경우에 발생하고 어떻게 해결할 수 있는가?
* 저장소의 원본과 캐시를 갱신하는 연산이 동시에 이뤄질 때 예외가 발생하여 롤백을 시도할 때 저장소와 캐시 상태의 정합성이 맞지 않을 수 있다.
* 데이터베이스 갱신과 캐시 갱신을 묶어 원자적으로 처리한다.
* 캐시 갱신을 트랜잭션 외부에서 수행하여 데이터베이스 갱신이 정상적으로 완료된 경우에만 수행한다.

> 캐시에서 잦은 eviction이 발생할 때 overprovision로 해결할 수 있다. 그런데 물리적인 메모리보다 더 많은 용량을 할당했는데 어떻게 동작하는 걸까?
* 가상 메모리를 이용하여 물리적인 메모리를 초과하는 부분을 디스크의 swap 영역에 저장하여 메모리 부족 문제를 해결한다.
</details>

<br>

### stateless한 웹 계층은 왜 필요할까?

* 세션을 사용할 때 stateless를 위해 세션 정보를 NoSQL에 저장하고 사용한다. JWT로 인증하면 이와 같은 작업이 필요없을 것 같은데 왜 세션을 사용할까? JWT의 단점 측면에서 이야기하라.
* 쿠키와 세션을 어떻게 조합할 수 있을까?

<details>
<summary><h4>해설</h4></summary>

> stateless한 웹 계층은 왜 필요할까?
* 세션으로 인증하는 경우 같은 클라이언트로부터의 요청은 항상 같은 서버로 전송되어야 한다.

> 세션을 사용할 때 stateless를 위해 세션 정보를 NoSQL에 저장하고 사용한다. JWT로 인증하면 이와 같은 작업이 필요없을 것 같은데 왜 세션을 사용할까? JWT의 단점 측면에서 이야기하라.
* JWT에는 클레임 정보가 포함되어있어 토큰의 크기가 커질 수 있다. 매 요청마다 토큰을 전송해야 하므로 네트워크 대역폭에 영향을 미칠 수 있다.
* JWT는 클라이언트에서 디코딩이 가능하므로 중요한 정보를 포함하지 않아야한다.
* 클라이언트를 상태를 유지해야할 경우 stateless한 JWT로는 한계가 있다.

> 쿠키와 세션을 어떻게 조합할 수 있을까?
* 쿠키에 세션 식별자를 저장하여 서버로 전송합니다. 서버는 세션 식별자로 사용자의 세션을 식별하고 그에 따른 처리를 수행할 수 있어 세션 추적이 가능하다.
* 세션 식별자에 대한 조작의 경우, 다음과 같은 해결 방법이 있다.

  * HTTPS 사용: 데이터를 암호화하고 안전하게 전송함으로써 중간자 공격(Man-in-the-Middle Attack, MITM)을 방지
  * Secure Flag: 세션 식별자 쿠키에 "Secure" 플래그를 설정하여 HTTPS 연결에서만 전송되도록 보장
  * HttpOnly Flag: 세션 식별자 쿠키에 "HttpOnly" 플래그를 설정하여 JavaScript를 통한 접근을 방지
  * SameSite 설정: 쿠키에 SameSite 속성을 설정하여 외부 사이트로의 요청을 제한
</details>

<br>

### 데이터베이스 다중화를 위해 sharding을 사용한다면 발생할 수 있는 문제점은 무엇인가?

* sharding key의 기준은 어떻게 정할 수 있을까?
* sharding 구조에서 특정 노드에 장애가 발생 시 발생할 수 있는 문제점은 무엇인가?

<details>
<summary><h4>해설</h4></summary>

> 데이터베이스 다중화를 위해 sharding을 사용한다면 발생할 수 있는 문제점은 무엇인가?
* 재샤딩(resharding): 샤드간 불균등으로 인해 어느 샤드에 할당된 공간 소모가 빨리 진행되어 샤드 소진(shard exhaustion)이 발생하면 샤드 키를 계산하는 함수를 변경하고 데이터를 재배치 해야함
* 유명인사(celebrity) 문제 혹은 핫스팟 키(hotspot key): 특정 샤드에 질의가 집중되어 서버에 과부하가 걸리는 문제이며 celebrity 각각에 샤드 하나 씩을 할당해야할 수도 있고 심지어는 더 잘게 쪼개야할 수도 있음
* 조인과 비정규화(join and de-normalization): 하나의 데이터베이스를 여러 샤드 서버로 쪼개고 나면 여러 샤드에 걸친 데이터를 조인하기 힘들어짐

  * 해결 방법 중 하나는 데이터베이스를 비정규화하여 하나의 테이블에서 질의가 수행될 수 있도록 하는 것

> sharding key의 기준은 어떻게 정할 수 있을까?
* 자주 사용되는 쿼리에 대한 조인이나 필터링에 사용되는 컬럼이 sharding key로 적합할 수 있다.
* DDD의 경우 애그리거트 루트 엔티티를 기준으로 sharding key를 만든다.
  
    * 하위 엔티티들과 루트 엔티티들의 join이 발생할 수밖에 없기 때문이다.

> sharding 구조에서 특정 노드에 장애가 발생 시 발생할 수 있는 문제점은 무엇인가?
* 해당 노드가 보유한 데이터에 대하여 가용성이 보장되지 않는다.
</details>
