# Ch07. 분산 시스템을 위한 유일 ID 생성기 설계

### 분산 시스템에서 auto_increment를 사용한 ID 생성 전략이 문제가 될 수 있는 이유는 무엇인가요?

* multi-master replication 전략에서 여러 데이터 센터에 걸쳐 규모를 늘리기 어려운 이유는 무엇인가요?
* multi-master replication 전략에서 ID 값의 시간 순서를 보장하지 못하고 scale-in and out에 어려움이 생기는 이유는 무엇인가요?

<details>
<summary><h4>해설</h4></summary>

> 분산 시스템에서 auto_increment를 사용한 ID 생성 전략이 문제가 될 수 있는 이유는 무엇인가요?

* 두 개 이상의 데이터베이스 서버를 사용하는 경우 auto_increment로 생성한 ID가 중복될 수 있습니다. 예를 들어, sharding을 사용하여 데이터베이스를 분산하면서 auto_increment를
  사용하면, 각 데이터베이스 서버마다 ID가 중복될 수 있습니다.

> multi-master replication 전략에서 여러 데이터 센터에 걸쳐 규모를 늘리기 어려운 이유는 무엇인가요?

* 아무리 생각해도 몰라서 질문에 넣었습니다 😅

> multi-master replication 전략에서 ID 값의 시간 순서를 보장하지 못하고 scale-in and out에 어려움이 생기는 이유는 무엇인가요?

* 예를 들어 서버가 3대 일 때, 2-1-3 순서로 저장할 경우 시간 순서를 보장하기 위해선 2-1-3 순으로 ID 값이 증가해야하지만 1-2-3 순서로 ID가 저장되기 때문입니다.
* 또한, 서버의 규모가 줄어들거나 늘어날 때 수정된 k 값에 대응하기 위해 전체 ID 값을 변경해야합니다.

</details>


<br>

### UUID 생성 전략의 장점과 단점은 무엇인가요?

* 컬럼 크기에 따른 인덱스 성능 저하의 이유는 무엇인가요?
* 티켓 서버의 가장 큰 단점은 무엇인가요?

<details>
<summary><h4>해설</h4></summary>

> UUID 생성 전략의 장점과 단점은 무엇인가요?

* stateless한 전략으로 ID 생성 서버의 스케일링에 유연합니다.
* ID의 크기가 128bit로 크기 때문에 디스크 공간을 많이 차지하고 인덱스 사용시 어려움을 겪을 수 있습니다.

> 컬럼 크기에 따른 인덱스 성능 저하의 이유는 무엇인가요?

* 인덱스는 특정 컬럼의 값과 해당 값이 존재하는 레코드의 위치 정보를 매핑한 데이터 구조입니다. 따라서 컬럼의 값 크기가 클 수록 인덱스의 크기도 증가합니다. B-tree 구조로 구성된 인덱스의 경우 leaf
  노드가 디스크의 블록과 대응되기 때문에 컬럼의 크기가 클수록 블록에 저장될 수 있는 인덱스 키의 수가 줄어듭니다. 따라서 디스크 I/O가 증가하고 인덱스의 성능이 저하됩니다.

> 티켓 서버의 가장 큰 단점은 무엇인가요?

* 웹 서버가 ID 생성을 위해 하나의 티켓 서버에 의존하기 때문에 SPOF가 발생할 수 있습니다. 이를 해결하기 위해 여러 대의 티켓 서버를 준비하는 것은 또 다른 동기화 문제를 낳으므로 티켓 서버를 사용하는 의미가 퇴색됩니다.

</details>
